<!doctype html>
<html lang="ja" data-theme="light">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>CSV / Excel Viewer — Tooltip列をドロップダウンで追加</title>

  <!-- Libraries -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  <style>
    :root{
      /* Light */
      --bg:#f6f7fb; --bg-grad-1:#eff4ff; --bg-grad-2:#f6f9ff;
      --card:#ffffff; --text:#0f172a; --muted:#475569; --line:#e5e7eb;
      --accent:#2563eb; --accent-weak:#dbeafe; --ring:#06b6d4;
      --input-bg:#f1f5f9; --shadow:0 6px 18px rgba(2,6,23,.08);
      --good:#16a34a; --warn:#ca8a04; --danger:#dc2626;
    }
    [data-theme="dark"]{
      /* Dark */
      --bg:#0b0f17; --bg-grad-1:#0b1020; --bg-grad-2:#0c1424;
      --card:#0e1421; --text:#e5e7eb; --muted:#94a3b8; --line:#1f2937;
      --accent:#60a5fa; --accent-weak:#1e293b; --ring:#22d3ee;
      --input-bg:#0f172a; --shadow:0 10px 30px rgba(0,0,0,.32);
      --good:#22c55e; --warn:#f59e0b; --danger:#f87171;
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0}
    body{
      font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Hiragino Kaku Gothic ProN", "Yu Gothic", Meiryo, sans-serif;
      color:var(--text);
      background:
        radial-gradient(900px 600px at -10% -10%, var(--bg-grad-1) 0%, transparent 60%),
        radial-gradient(800px 500px at 110% 10%, var(--bg-grad-2) 0%, transparent 50%), var(--bg);
      line-height:1.6;
    }

    /* Topbar */
    .topbar{position:sticky;top:0;z-index:20;display:flex;gap:12px;align-items:center;padding:12px 16px;background:color-mix(in oklab, var(--card) 80%, transparent);backdrop-filter:blur(8px);border-bottom:1px solid var(--line)}
    .brand{font-weight:800;letter-spacing:.2px;font-size:16px}
    .spacer{flex:1}
    .btn{display:inline-flex;align-items:center;gap:8px;cursor:pointer;padding:10px 12px;border-radius:12px;border:1px solid var(--line);background:var(--card);color:var(--text);transition:transform .06s ease, background .2s ease, border-color .2s ease}
    .btn:hover{background:var(--accent-weak);border-color:color-mix(in oklab, var(--accent) 40%, var(--line))}
    .btn:focus-visible{outline:3px solid var(--ring);outline-offset:2px}
    .btn:active{transform:scale(.98)}

    .input{width:100%;border:none;outline:none;border-radius:12px;padding:10px 14px;font-size:14px;color:var(--text);background:var(--input-bg);transition:box-shadow .2s ease, background .2s ease}
    .input::placeholder{color:#8ba0be}
    .input:focus{box-shadow:0 0 0 2px var(--accent)}

    .toggle{display:inline-flex;gap:8px;align-items:center;font-size:12px;color:var(--muted)}
    .file-input{display:none}

    /* Layout */
    .wrap{max-width:1200px;margin:28px auto;padding:0 16px 40px}

    /* Drop */
    .drop{border:1.5px dashed color-mix(in oklab, var(--accent) 40%, var(--line));border-radius:18px;background:var(--card);
      display:flex;flex-direction:column;align-items:center;justify-content:center;gap:10px;text-align:center;padding:22px;min-height:110px}
    .pill{display:inline-block;padding:6px 10px;border-radius:999px;background:var(--accent-weak);color:color-mix(in oklab, var(--accent) 30%, var(--text));font-size:12px;border:1px solid var(--line)}
    .drop.dragover{outline:3px dashed var(--accent)}
    .status{margin:10px 2px;color:var(--muted);font-size:12px}

    /* Filter card */
    .filter-card{margin-top:14px;background:var(--card);border:1px solid var(--line);border-radius:16px;padding:12px;box-shadow:var(--shadow);
      display:grid;grid-template-columns:repeat(12,1fr);gap:12px;align-items:center}
    .field{grid-column:span 12;display:flex;align-items:center;gap:8px;flex-wrap:wrap}
    .field .mini { width: 180px; flex: 0 0 180px; }
    .field > .input:not(.mini) { flex: 1 1 auto; }
    .help{font-size:12px;color:var(--muted)}
    .clear-btn{border:none;background:var(--input-bg);color:var(--text);padding:10px 12px;border-radius:12px;cursor:pointer}
    .clear-btn:hover{background:var(--accent-weak)}
    .clear-btn:focus-visible{outline:3px solid var(--ring);outline-offset:2px}

    /* Table */
    .grid{margin-top:14px;border:1px solid var(--line);border-radius:14px;background:var(--card);position:relative;overflow:hidden}
    .table-scroll{overflow:auto;border-bottom:1px solid var(--line);max-height:60vh;scrollbar-gutter:stable both-edges;scrollbar-width:thin;scrollbar-color:#94a3b8 transparent}
    .table-scroll::-webkit-scrollbar{width:10px;height:10px}
    .table-scroll::-webkit-scrollbar-thumb{background:#94a3b8;border-radius:8px;border:2px solid transparent}
    table{width:100%;border-collapse:separate;border-spacing:0;table-layout:auto}
    thead th{position:sticky;top:0;background:color-mix(in oklab, var(--card) 85%, var(--accent-weak) 15%);color:#1f3b73;text-align:left;padding:10px 12px;border-bottom:1px solid var(--line);font-size:13px;white-space:nowrap;min-width:120px}
    thead th .label{cursor:pointer}
    tbody td{padding:9px 10px;border-bottom:1px solid color-mix(in oklab, var(--line) 70%, transparent);font-size:13.5px;white-space:normal;word-break:break-word;min-width:120px}
    tbody tr:nth-child(even) td{background:color-mix(in oklab, var(--card) 92%, var(--accent-weak) 8%)}
    tbody tr:hover td{background:color-mix(in oklab, var(--card) 85%, var(--accent-weak) 15%)}

    th{position:relative}
    .resizer{position:absolute;right:0;top:0;height:100%;width:6px;cursor:col-resize;user-select:none}

    /* Chart */
    .chart-panel{margin-top:14px;border:1px solid var(--line);border-radius:14px;background:var(--card);padding:12px;box-shadow:var(--shadow);display:none}
    .chart-header{display:flex;align-items:center;gap:12px;color:var(--muted)}
    .chart-header .hint{margin-left:auto;font-size:12px;color:var(--muted)}
    th.selected-x .label{outline:1.5px solid var(--accent);border-radius:6px;padding:2px 6px}
    th.selected-y .label{outline:1.5px solid var(--ring);border-radius:6px;padding:2px 6px}
    .chart-scroll{margin-top:8px;height:16px;overflow-x:auto;overflow-y:hidden;border:1px solid var(--line);border-radius:10px;background:var(--card);scrollbar-width:thin;scrollbar-color:#94a3b8 transparent}
    .chart-scroll::-webkit-scrollbar{height:12px}
    .chart-scroll::-webkit-scrollbar-thumb{background:#94a3b8;border-radius:8px;border:2px solid transparent}
    .chart-spacer{height:1px;width:100%}


     /* ▼ 追加: キャンバスの縦をベース固定（拡大し続けるのを防止） */
  #chartCanvas{
    display:block;
    height:220px;                 /* お好みで 180–280px */
    max-height:min(38svh, 320px); /* 画面の過半を占拠しないよう安全弁 */
    width:100% !important;        /* 親幅にフィット */
  }

    .axis-row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    select.input{appearance:none;background-image:url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="%238ba0be" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"/></svg>');background-repeat:no-repeat;background-position:right 10px center;padding-right:36px}

    /* キーワード入力の幅クランプ */
    .field > #searchBox{ flex: 0 1 clamp(260px, 45vw, 520px); width:auto; }
    @media (max-width: 720px){ .field{ flex-wrap: wrap; } .field > #searchBox{ flex: 1 1 100%; width: 100%; } }

    /* ▼ ツールチップ列のドロップダウン */
    .tt-selects{display:flex;gap:8px;flex-wrap:wrap}
    .tt-chip{display:inline-flex;align-items:center;gap:6px}
    .tt-chip > .rm{padding:8px 10px;border-radius:10px;border:1px solid var(--line);background:var(--input-bg);cursor:pointer}
    .tt-chip > .rm:hover{background:var(--accent-weak)}
  

/* === モバイル/タブレット最適化: ここから === */
@media (max-width: 960px){
  .topbar{flex-wrap:wrap; gap:10px}
  .wrap{padding:0 12px 28px}
  .table-scroll{max-height:56vh}
}
@media (max-width: 720px){
  .btn{flex:1 1 48%}
  .toggle{width:100%; justify-content:flex-start}
  .filter-card{grid-template-columns:1fr}
  .field{gap:8px}
  .field .mini{width:100%; flex:1 1 100%}
  .input{font-size:15px}
  thead th, tbody td{min-width:92px}
  thead th{font-size:12px}
  tbody td{font-size:13px}
  

  /* モバイルは少し低めでもOK（任意で微調整） */
  #chartCanvas{height:200px !important}
  .chart-header .hint{display:none}
  .table-scroll{max-height:52vh}
}
@media (max-width: 420px){
  .btn{flex:1 1 100%}
  .table-scroll{max-height:48vh}
  thead th, tbody td{min-width:84px}
}
/* === モバイル/タブレット最適化: ここまで === */



 /* ▼ 全ページのコピー操作を抑止 */
.no-copy, .no-copy *{
  -webkit-user-select: none;
  user-select: none;
  -webkit-touch-callout: none; /* iOSの長押しメニュー */
}

  </style>
</head>
<body class="no-copy">
  <div class="topbar" role="toolbar" aria-label="ビューア操作">
    <div class="brand">Viewer</div>
    <div class="spacer"></div>
    <button id="themeToggle" class="btn" aria-pressed="false" title="テーマ切替">🌓 テーマ</button>
    <label class="btn" for="file" title="ファイルを開く">📁 開く</label>
    <label class="toggle"><input id="useHeader" type="checkbox" checked> 1行目をヘッダー</label>
    <label class="toggle" style="gap:6px;">行: <input id="headerRow" type="number" min="1" value="1" step="1" style="width:80px;" aria-label="ヘッダーにする行番号"></label>
    <input id="file" class="file-input" type="file" accept=".csv,.xlsx,.xls,text/csv" />
  </div>

  <main id="main" class="wrap">
    <section id="drop" class="drop" aria-label="ファイルのドラッグ＆ドロップ領域">
      <div>
        <div class="pill">CSV / Excel</div>
        <h3 style="margin:6px 0 0 0;">ここにドラッグ＆ドロップ</h3>
        <p class="help" style="margin:0;color:#64748b">右上の「開く」からも選択できます</p>
      </div>
    </section>

    <p class="status" id="status" aria-live="polite">未読み込み</p>

    <!-- ===== 検索UI（1組） ===== -->
    <section class="filter-card" aria-label="フィルター">
      <div class="field">
        <select id="colSelect" class="input mini" aria-label="検索対象列">
          <option value="">--- 列を選択 ---</option>
        </select>
        <input id="searchBox" class="input" type="text" placeholder="キーワード（自動半角）" autocomplete="off" aria-label="検索語" />
        <select id="matchMode" class="input mini" aria-label="検索方法">
          <option value="contains">部分一致</option>
          <option value="eq">完全一致</option>
          <option value="starts">前方一致</option>
          <option value="ends">後方一致</option>
          <option value="last4">末尾4桁(数値)</option>
          <option value="num">数値一致</option>
        </select>
        <button id="clearBtn" class="clear-btn" title="入力をクリア">✖ クリア</button>
      </div>

      <div class="field" style="justify-content:flex-start;">
        <div class="axis-row">
          <span class="pill">X軸</span>
          <select id="axisXSelect" class="input" style="width:260px;" aria-label="X軸を選択"></select>
          <span class="pill">Y軸</span>
          <select id="axisYSelect" class="input" style="width:260px;" aria-label="Y軸を選択"></select>
          <span class="help">列見出しをタップでも選択できます</span>
        </div>
      </div>

      <!-- 固定のツールチップ表示 ON/OFF（Xラベルを左へ／全体平均は初期ON） -->
      <div class="field" id="ttControls">
        <span class="pill">ツールチップ表示</span>
        <label class="toggle"><input type="checkbox" id="ttXLabel" checked> Xラベル</label>
        <label class="toggle"><input type="checkbox" id="ttVal" checked> 値</label>
        <label class="toggle"><input type="checkbox" id="ttDiff" checked> 前回比</label>
        <label class="toggle"><input type="checkbox" id="ttRate" checked> 変化率%</label>
        <label class="toggle"><input type="checkbox" id="ttMonthly" checked> 全体平均</label>
      </div>

      <!-- ▼ ドロップダウンを「＋」で増やして、列の値をツールチップに追加 -->
      <div class="field">
        <span class="pill">追加で表示する列</span>
        <div id="ttSelects" class="tt-selects"></div>
        <button id="ttAdd" class="clear-btn" type="button">＋ 追加</button>
        <button id="ttClear" class="clear-btn" type="button">全削除</button>
      </div>
      <!-- ▲ ここまで -->
    </section>

    <!-- Chart -->
    <section id="chartPanel" class="chart-panel no-copy" aria-label="チャート領域">
      <div class="chart-header">
        <div class="pill">チャート</div>
        <div class="axis-state">X: <span id="axisXLabel">未選択</span> / Y: <span id="axisYLabel">未選択</span></div>
        <div class="hint">列見出しをタップ → <b>横軸 → 縦軸</b> ／ 表示件数: <select id="chartWindowSelect" class="input mini" style="width:100px;"><option value="25">25</option><option value="50" selected>50</option><option value="100">100</option><option value="200">200</option><option value="500">500</option></select></div>
      </div>
      <canvas id="chartCanvas" height="56" aria-label="グラフ"></canvas>
      <div class="chart-scroll" id="chartScroll"><div class="chart-spacer" id="chartSpacer"></div></div>
    </section>

    <!-- Table -->
    <section class="grid no-copy" id="grid" aria-label="データテーブル">
      <div class="table-scroll" id="tableScroll" tabindex="0">
        <table id="dataTable"><thead></thead><tbody></tbody></table>
      </div>
    </section>
  </main>

  <script>
    // ===== DOM refs =====
    const drop = document.getElementById('drop');
    const fileInput = document.getElementById('file');
    const tableScroll = document.getElementById('tableScroll');
    const statusEl = document.getElementById('status');
    const useHeader = document.getElementById('useHeader');
    const headerRowInput = document.getElementById('headerRow');

    const table = document.getElementById('dataTable');
    const thead = table.querySelector('thead');
    const tbody = table.querySelector('tbody');

    // 検索(1組)
    const colSelect = document.getElementById('colSelect');
    const searchBox = document.getElementById('searchBox');
    const matchMode = document.getElementById('matchMode');
    const clearBtn  = document.getElementById('clearBtn');

    // Axis selectors
    const axisXSel = document.getElementById('axisXSelect');
    const axisYSel = document.getElementById('axisYSelect');

    // ツールチップ（固定項目）
    const ttVal     = document.getElementById('ttVal');
    const ttDiff    = document.getElementById('ttDiff');
    const ttRate    = document.getElementById('ttRate');
    const ttMonthly = document.getElementById('ttMonthly'); // 表示名は全体平均
    const ttXLabel  = document.getElementById('ttXLabel');

    // ツールチップ列（ドロップダウンで追加）
    const ttSelects = document.getElementById('ttSelects');
    const ttAdd     = document.getElementById('ttAdd');
    const ttClear   = document.getElementById('ttClear');

    // ===== Theme toggle =====
    const themeToggle = document.getElementById('themeToggle');
    const rootEl = document.documentElement;
    function applyTheme(t){
      rootEl.setAttribute('data-theme', t==='dark' ? 'dark' : 'light');
      localStorage.setItem('theme', t);
      themeToggle.setAttribute('aria-pressed', t==='dark');
    }
    applyTheme(localStorage.getItem('theme') || 'light');
    themeToggle.addEventListener('click', ()=>{
      const next = (rootEl.getAttribute('data-theme')==='dark') ? 'light' : 'dark';
      applyTheme(next);
    });

    // ===== State =====
    let currentData = [];
    let viewRows = [];
    let headerRowIndex = 0; // 0-based header row index

    // ★ 追加: 現在のファイル名を保持して、ステータス右側に出す
    let currentFileName = ""; // ← ここに保持

    // chart state
    let chartInstance = null;
    let axisX = -1, axisY = -1;
    let CHART_WINDOW = 50;
    let chartViewportStart = 0;
    let lastChartTotal = 0;
    let winRowIndexMap = null; // 可視ウィンドウの各点→元行index

    let rowHeight = 0; let visCount = 0; const overscan = 100;

    // ===== Utils =====
    function toHalfWidth(str){ if(!str) return ''; return str.replace(/[！-～]/g, s => String.fromCharCode(s.charCodeAt(0) - 0xFEE0)).replace(/　/g, ' '); }
    function escapeHtml(str){ return String(str).replace(/[&<>"']/g,s=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[s])); }
    function asNumberMaybe(v){ const n=Number(String(v).replace(/,/g,'')); return Number.isFinite(n)?n:null; }
    function updateStatus(t){ statusEl.textContent = t; }

    function attachHalfWidthInput(inputEl, onAfter){
      let composing = false;
      inputEl.addEventListener('compositionstart', () => composing = true);
      inputEl.addEventListener('compositionend', () => { composing = false; normalize(); });
      inputEl.addEventListener('input', (e) => { if (e.isComposing || composing) return; normalize(); });
      function normalize(){
        const start = inputEl.selectionStart; const end = inputEl.selectionEnd;
        const newVal = toHalfWidth(inputEl.value);
        if (inputEl.value !== newVal){ inputEl.value = newVal; try { inputEl.setSelectionRange(start, end); } catch(_){} }
        if (typeof onAfter === 'function') onAfter();
      }
    }

    // ===== Header row sync =====
    function clampedHeaderRow(){
      const max = Math.max(1, currentData.length || 1);
      const val = Math.min(Math.max(1, Number(headerRowInput?.value)||1), max);
      if (headerRowInput) headerRowInput.value = val;
      headerRowIndex = Math.max(0, val - 1);
    }
    function syncHeaderRowInputEnabled(){
      if (!headerRowInput) return;
      headerRowInput.disabled = !useHeader.checked || !(currentData?.length);
    }
    useHeader.addEventListener('change', ()=>{
      syncHeaderRowInputEnabled();
      clampedHeaderRow();
      if(currentData?.length){ renderTable(currentData); resetChartViewport(); renderChartIfReady(); }
    });
    if (headerRowInput){
      headerRowInput.addEventListener('change', ()=>{
        clampedHeaderRow();
        if(currentData?.length){ renderTable(currentData); resetChartViewport(); renderChartIfReady(); }
      });
    }

    // ===== Virtual table =====
    function ensurePadRows(){
      if(!tbody.querySelector('tr.pad-top')){
        const trTop=document.createElement('tr'); trTop.className='pad-row pad-top';
        const tdTop=document.createElement('td'); tdTop.className='pad-cell'; tdTop.colSpan = thead.querySelectorAll('th').length || 1;
        trTop.appendChild(tdTop); tbody.prepend(trTop);
      }
      if(!tbody.querySelector('tr.pad-bottom')){
        const trBot=document.createElement('tr'); trBot.className='pad-row pad-bottom';
        const tdBot=document.createElement('td'); tdBot.className='pad-cell'; tdBot.colSpan = thead.querySelectorAll('th').length || 1;
        trBot.appendChild(tdBot); tbody.appendChild(trBot);
      }
    }
    function measureRowHeight(){
      const tmp=document.createElement('tr');
      const cols=thead.querySelectorAll('th').length || (currentData[0]?.length||1);
      for(let i=0;i<cols;i++){ const td=document.createElement('td'); td.textContent='A'; tmp.appendChild(td); }
      tbody.appendChild(tmp); rowHeight = tmp.getBoundingClientRect().height || 24; tmp.remove();
      visCount = Math.ceil(tableScroll.clientHeight / rowHeight) + overscan;
    }
    function renderVirtual(rows){
      ensurePadRows(); if(rowHeight===0) measureRowHeight();
      const total = rows.length; const scrollTop = tableScroll.scrollTop;
      const start = Math.max(0, Math.floor(scrollTop / rowHeight) - overscan);
      const end = Math.min(total, start + visCount);
      const topPad = start * rowHeight; const bottomPad = Math.max(0, (total - end) * rowHeight);
      const padTop = tbody.querySelector('tr.pad-top .pad-cell'); const padBot = tbody.querySelector('tr.pad-bottom .pad-cell');
      padTop.style.height = topPad + 'px'; padBot.style.height = bottomPad + 'px';
      [...tbody.querySelectorAll('tr')].forEach(tr=>{ if(!tr.classList.contains('pad-row') && !tr.matches('thead *')) tr.remove(); });
      const frag = document.createDocumentFragment();
      for(let i=start;i<end;i++){
        const r = rows[i]; const tr = document.createElement('tr'); tr.dataset.abs = String(currentData.indexOf(r));
        for(const c of r){ const td=document.createElement('td'); td.textContent = String(c ?? ''); tr.appendChild(td); }
        frag.appendChild(tr);
      }
      const afterTop = tbody.querySelector('tr.pad-top'); afterTop.after(frag);

      // ★ 追加: ステータス表示にファイル名を右側へ併記
      const title = currentFileName ? ` ｜ ${currentFileName}` : "";
      updateStatus(`表示中 ${start+1}–${Math.max(start, end)} / ${total} 行${title}`);
    }
    tableScroll.addEventListener('scroll', ()=> requestAnimationFrame(()=> renderVirtual(viewRows)), {passive:true});

    // ===== File handling =====
    ['dragenter','dragover'].forEach(evt=>drop.addEventListener(evt, e=>{ e.preventDefault(); drop.classList.add('dragover'); }));
    ['dragleave','drop'].forEach(evt=>drop.addEventListener(evt, e=>{ e.preventDefault(); if(evt==='drop') return; drop.classList.remove('dragover'); }));
    drop.addEventListener('drop', e=>{ drop.classList.remove('dragover'); const f=e.dataTransfer.files?.[0]; if(f) handleFile(f); });
    drop.addEventListener('click', ()=> fileInput.click());
    fileInput.addEventListener('change', e=>{ const f=e.target.files?.[0]; if(f) handleFile(f); });
    useHeader.addEventListener('change', ()=>{ if(currentData.length) { renderTable(currentData); resetChartViewport(); renderChartIfReady(); } });

    function handleFile(file){
      try{
        // ★ 追加: ファイル名を保持
        currentFileName = file?.name || "";

        updateStatus(`読み込み中: ${file.name}`);
        const lower = file.name.toLowerCase();
        file.arrayBuffer().then(buf=>{
          if(/\.xlsx?$/.test(lower)) parseExcel(buf, file.name);
          else parseCSV(decodeBuffer(buf), file.name);
        });
        document.getElementById('drop').style.display = 'none';
        resetChartViewport(); renderChartIfReady();
      }catch(err){ console.error(err); alert('読み込みエラー: '+err.message); updateStatus('読み込みエラー'); }
    }
    function decodeBuffer(buf){
      const view=new Uint8Array(buf); let text;
      try { text=new TextDecoder('utf-8',{fatal:true}).decode(view);} catch(_){
        try{text=new TextDecoder('shift-jis').decode(view);} catch(_){
          try{text=new TextDecoder('euc-jp').decode(view);} catch(_){ text=new TextDecoder('utf-8').decode(view); }
        }
      } return text;
    }
    function parseExcel(arrayBuffer, filename){
      try{
        const wb=XLSX.read(arrayBuffer,{type:'array'}); const sheet=wb.Sheets[wb.SheetNames[0]];
        const data=XLSX.utils.sheet_to_json(sheet,{header:1, blankRows:false});
        currentData=data; if (headerRowInput){ headerRowInput.value=1; } clampedHeaderRow(); syncHeaderRowInputEnabled(); renderTable(data); updateStatus(`読み込み完了: ${filename} / 行数:${data.length} 列数:${data[0]?.length ?? 0}`);
        resetChartViewport(); renderChartIfReady();
      }catch(err){ console.error(err); alert('Excelの解析に失敗しました: '+err.message); updateStatus('Excel解析エラー'); }
    }
    function parseCSV(text, filename){
      try{
        const res=Papa.parse(text,{header:false, skipEmptyLines:'greedy', dynamicTyping:false, delimitersToGuess:[',','\t',';','|']});
        currentData=res.data; if (headerRowInput){ headerRowInput.value=1; } clampedHeaderRow(); syncHeaderRowInputEnabled(); renderTable(res.data); updateStatus(`読み込み完了: ${filename} / 行数:${res.data.length} 列数:${res.data[0]?.length ?? 0}`);
        resetChartViewport(); renderChartIfReady();
      }catch(err){ console.error(err); alert('CSV解析に失敗しました: '+err.message); updateStatus('CSV解析エラー'); }
    }

    // ===== Table render =====
    function getHeadersArray(){
      if(!currentData?.length) return [];
      if(useHeader.checked) return currentData[headerRowIndex] || [];
      const n = currentData[0]?.length || 0;
      return Array.from({length:n}, (_,i)=>`Col ${i+1}`);
    }

    function renderTable(data){
      if(!data?.length){ thead.innerHTML=''; tbody.innerHTML='<tr><td style="padding:16px;color:#94a3b8;text-align:center;">データがありません。</td></tr>'; return; }
      const useHdr=useHeader.checked;
      if(useHdr){ headerRowIndex = Math.min(headerRowIndex, Math.max(0, data.length-1)); }
      const hdr = useHdr ? (data[headerRowIndex] || []) : (data[0] ? data[0].map((_,i)=>`Col ${i+1}`) : []);
      const rows = useHdr ? data.slice(headerRowIndex + 1) : data; viewRows = rows;
      thead.innerHTML=`<tr>${hdr.map((h,i)=>`<th data-col="${i}"><span class="label" role="button" tabindex="0" aria-label="${escapeHtml(h ?? '')} を軸に選択">${escapeHtml(h ?? '')}</span><div class="resizer" data-col="${i}"></div></th>`).join('')}</tr>`;
      renderVirtual(viewRows);
      Array.from(tbody.querySelectorAll('tr[data-abs]')).forEach(tr=>{ const abs=Number(tr.dataset.abs); tr.classList.toggle('is-header-row', useHdr && abs===headerRowIndex); });
      table.querySelectorAll('.resizer').forEach(h=> h.addEventListener('mousedown', initResize));

      // 軸ピッカー/セレクタ更新
      attachAxisPickers(); populateAxisSelectors();

      // 列セレクタ更新 & 現在の条件でフィルタ
      populateColSelector();

      // ツールチップ列ドロップダウンの選択肢を更新
      refreshTooltipSelectOptions();

      multiFilter();
      renderChartIfReady();
    }

    // Resize columns
    let startX,startW,colIdxResize;
    function initResize(e){ colIdxResize=Number(e.target.getAttribute('data-col')); const th=e.target.parentElement; startX=e.pageX; startW=th.offsetWidth; document.addEventListener('mousemove', onResize); document.addEventListener('mouseup', stopResize, {once:true}); }
    function onResize(e){ const dx=e.pageX-startX; const newW=Math.max(80,startW+dx); setColumnWidth(colIdxResize,newW); }
    function stopResize(){ document.removeEventListener('mousemove', onResize); }
    function setColumnWidth(idx,px){ table.querySelectorAll(`th[data-col="${idx}"]`).forEach(th=> th.style.width=px+'px'); table.querySelectorAll('tbody tr').forEach(tr=>{ const td=tr.children[idx]; if(td) td.style.width=px+'px'; }); }

    // ====== 検索（1組）======
    function populateColSelector(){
      const hdrs = getHeadersArray();
      colSelect.innerHTML = '<option value="">--- 列を選択 ---</option>';
      hdrs.forEach((h, idx)=>{
        const opt = document.createElement('option');
        opt.value = String(idx);
        opt.textContent = `${idx+1}: ${h ?? `Col ${idx+1}`}`;
        colSelect.appendChild(opt);
      });
    }

    function makeMatcher(rawQuery, mode){
      const q = String(toHalfWidth(rawQuery || '')).trim();
      if (!q) return () => true;
      const qq = q.toLowerCase();
      function asNum(v){
        const n = Number(String(v ?? '').replace(/,/g,'').trim());
        return Number.isFinite(n) ? n : null;
      }
      return (cell) => {
        const valStr = String(cell ?? '');
        const vv = valStr.toLowerCase();
        switch(mode){
          case 'eq':     return vv === qq;
          case 'starts': return vv.startsWith(qq);
          case 'ends':   return vv.endsWith(qq);
          case 'num': {
            const qn = asNum(q); const vn = asNum(cell);
            return qn != null && vn != null && vn === qn;
          }
          case 'last4': {
            const q4 = q.replace(/\D/g,'').slice(-4);
            if (!q4) return true;
            const cDigits = valStr.replace(/\D/g,'');
            return cDigits.endsWith(q4);
          }
          case 'contains':
          default: return vv.includes(qq);
        }
      };
    }

    function multiFilter(){
      const useHdr = useHeader.checked;
      const head = useHdr ? [currentData[headerRowIndex]] : [];
      const rows = useHdr ? currentData.slice(headerRowIndex + 1) : currentData;

      const idxSel = colSelect?.value ?? '';
      const apply = idxSel !== '';

      const matcher = makeMatcher(searchBox.value, matchMode?.value || 'contains');

      const filtered = rows.filter(r => !apply ? true : matcher(r[Number(idxSel)]) );

      const out = head.concat(filtered);
      renderVirtual(out.slice(useHdr?1:0));
      viewRows = out.slice(useHdr?1:0);
      resetChartViewport();
      renderChartIfReady();
    }

    attachHalfWidthInput(searchBox, multiFilter);
    [colSelect, matchMode].forEach(el=> el?.addEventListener('change', multiFilter));
    clearBtn.addEventListener('click', ()=>{
      searchBox.value = '';
      if (matchMode) matchMode.value = 'contains';
      populateColSelector();
      renderTable(currentData);
      resetChartViewport();
      renderChartIfReady();
    });

    // ===== Chart =====
    const chartPanel   = document.getElementById('chartPanel');
    const axisXLabel   = document.getElementById('axisXLabel');
    const axisYLabel   = document.getElementById('axisYLabel');
    const chartCanvas  = document.getElementById('chartCanvas');
    const chartScroll  = document.getElementById('chartScroll');
    const chartSpacer  = document.getElementById('chartSpacer');

    // ▼ 表示件数セレクトのイベント
    const chartWindowSelect = document.getElementById('chartWindowSelect');
    if (chartWindowSelect) {
      // 初期同期
      chartWindowSelect.value = String(CHART_WINDOW);
      chartWindowSelect.addEventListener('change', () => {
        const v = Number(chartWindowSelect.value) || 50;
        CHART_WINDOW = Math.max(1, v);
        resetChartViewport();
        renderChartIfReady();
      });
    }

    function resetAxes(){ axisX=-1; axisY=-1; axisXLabel.textContent='未選択'; axisYLabel.textContent='未選択'; chartPanel.style.display='none'; if(chartInstance){ chartInstance.destroy(); chartInstance=null; } if(axisXSel) axisXSel.value=''; if(axisYSel) axisYSel.value=''; resetChartViewport(); }

    function attachAxisPickers(){ const hdrCells = table.querySelectorAll('thead th .label'); hdrCells.forEach((lbl, idx)=>{ const handler = ()=>{ if(axisX < 0){ axisX = idx; } else if(axisY < 0 && idx !== axisX){ axisY = idx; } else if(idx === axisX){ resetAxes(); axisX = idx; } else { axisY = idx; } updateAxisUI(); resetChartViewport(); renderChartIfReady(); }; lbl.addEventListener('click', handler, {passive:true}); lbl.addEventListener('keydown', (e)=>{ if(e.key==='Enter' || e.key===' '){ e.preventDefault(); handler(); } }); }); }
    function updateAxisUI(){ const hdr = getHeadersArray(); table.querySelectorAll('thead th').forEach((th,i)=>{ th.classList.toggle('selected-x', i===axisX); th.classList.toggle('selected-y', i===axisY); }); axisXLabel.textContent = axisX>=0 ? String(hdr[axisX] ?? `Col ${axisX+1}`) : '未選択'; axisYLabel.textContent = axisY>=0 ? String(hdr[axisY] ?? `Col ${axisY+1}`) : '未選択'; }
    function populateAxisSelectors(){ if(!axisXSel || !axisYSel) return; const hdrs = getHeadersArray(); axisXSel.innerHTML = ''; axisYSel.innerHTML = ''; const e1 = document.createElement('option'); e1.value=''; e1.textContent='---'; const e2 = e1.cloneNode(true); axisXSel.appendChild(e1); axisYSel.appendChild(e2); hdrs.forEach((h, idx)=>{ const o1 = document.createElement('option'); o1.value=idx; o1.textContent = `${idx+1}: ${h}`; const o2 = o1.cloneNode(true); axisXSel.appendChild(o1); axisYSel.appendChild(o2); }); axisXSel.value=''; axisYSel.value=''; }
    if(axisXSel) axisXSel.addEventListener('change', ()=>{ axisX = axisXSel.value==='' ? -1 : Number(axisXSel.value); updateAxisUI(); resetChartViewport(); renderChartIfReady(); });
    if(axisYSel) axisYSel.addEventListener('change', ()=>{ axisY = axisYSel.value==='' ? -1 : Number(axisYSel.value); updateAxisUI(); resetChartViewport(); renderChartIfReady(); });

    // ==== 固定ツールチップ項目 ====
    function ttPrefs(){
      return {
        val:     !!ttVal?.checked,
        diff:    !!ttDiff?.checked,
        rate:    !!ttRate?.checked,
        monthly: !!ttMonthly?.checked, // 表示名は「全体平均」
        xLabel:  !!ttXLabel?.checked,
      };
    }
    [ttVal, ttDiff, ttRate, ttMonthly, ttXLabel].forEach(el=>{
      el?.addEventListener('change', ()=> renderChartIfReady());
    });

    // ==== 追加列セレクタ（ドロップダウン） ====
    function makeHeaderOptionsHTML(){
      const hdrs = getHeadersArray();
      let html = '<option value="">--- 列 ---</option>';
      hdrs.forEach((h,i)=>{ html += `<option value="${i}">${i+1}: ${escapeHtml(h ?? `Col ${i+1}`)}</option>`; });
      return html;
    }
    function addTooltipSelect(initialValue=''){
      const wrap = document.createElement('span'); wrap.className='tt-chip';
      const sel = document.createElement('select'); sel.className='input mini'; sel.innerHTML = makeHeaderOptionsHTML(); sel.value = initialValue;
      const rm = document.createElement('button'); rm.type='button'; rm.className='rm'; rm.textContent='×'; rm.title='この選択を削除';
      rm.addEventListener('click', ()=>{ wrap.remove(); renderChartIfReady(); });
      sel.addEventListener('change', ()=> renderChartIfReady());
      wrap.appendChild(sel); wrap.appendChild(rm);
      ttSelects.appendChild(wrap);
    }
    function getSelectedTooltipCols(){
      const arr = [];
      ttSelects.querySelectorAll('select').forEach(sel=>{
        if(sel.value !== '') arr.push(Number(sel.value));
      });
      // 重複除去（左から優先）
      return [...new Set(arr)];
    }
    function refreshTooltipSelectOptions(){
      const selects = ttSelects.querySelectorAll('select');
      const html = makeHeaderOptionsHTML();
      if(selects.length === 0) addTooltipSelect(''); // 1個は出しておく
      ttSelects.querySelectorAll('select').forEach(sel=>{
        const prev = sel.value;
        sel.innerHTML = html;
        sel.value = [...sel.options].some(o=>o.value===prev) ? prev : '';
      });
    }
    ttAdd.addEventListener('click', ()=> addTooltipSelect(''));
    ttClear.addEventListener('click', ()=>{ ttSelects.innerHTML=''; addTooltipSelect(''); renderChartIfReady(); });

    // ====== データ収集（チャート用）======
    function collectXY(){
      const rows = viewRows || (useHeader.checked ? currentData.slice(1) : currentData);
      const X = [], Y = [], idx = [];
      for (let i=0;i<rows.length;i++) {
        const r = rows[i]; if (!r) continue;
        const xv = r[axisX]; const yv = asNumberMaybe(r[axisY]);
        if (yv == null) continue;
        if (xv === undefined || xv === null || String(xv).trim() === '') continue;
        X.push(xv); Y.push(yv); idx.push(i);
      }
      return { X, Y, idx };
    }
    function guessType(X){
      let numericCount = 0, dateCount = 0;
      for (const x of X){ if (asNumberMaybe(x)!=null) numericCount++; else if (!isNaN(Date.parse(String(x)))) dateCount++; }
      const n = X.length || 1;
      if (numericCount/n > 0.6) return 'scatter';
      if (dateCount/n > 0.6) return 'line';
      return 'bar';
    }
    function aggregateCategoriesWithRep(X, Y, idx){
      const map = new Map();        // key -> sum
      const rep = new Map();        // key -> first row index
      for (let i=0;i<X.length;i++){
        const k = String(X[i]);
        map.set(k, (map.get(k)||0) + Y[i]);
        if(!rep.has(k)) rep.set(k, idx[i]);
      }
      const labels = [...map.keys()];
      const values = labels.map(k => map.get(k));
      const rowIndexMap = labels.map(k => rep.get(k));
      return {labels, values, rowIndexMap};
    }
    function toDateSortedWithRep(X, Y, idx){
      const items = [];
      for(let i=0;i<X.length;i++){
        const t = Date.parse(String(X[i])); if(!isNaN(t)) items.push({t, y:Y[i], ri:idx[i]});
      }
      items.sort((a,b)=>a.t-b.t);
      const byDay = new Map(); // key -> {sum,c,rep}
      for(const it of items){
        const d = new Date(it.t);
        const key = d.toISOString().slice(0,10);
        let ent = byDay.get(key); if(!ent) ent = {sum:0,c:0,rep:null};
        ent.sum += it.y; ent.c += 1; if(ent.rep==null) ent.rep = it.ri;
        byDay.set(key, ent);
      }
      const labels = [...byDay.keys()];
      const values = labels.map(k => byDay.get(k).sum / byDay.get(k).c);
      const rowIndexMap = labels.map(k => byDay.get(k).rep);
      return {labels, values, rowIndexMap};
    }

    // ▼ ツールチップ本文を構築（Xラベルはここでは出さない）
    function buildTooltipLines(ctx, kind){
      const p = ttPrefs();
      const lines = [];

      // y値
      const y = (kind === 'scatter')
        ? (ctx.raw?.y ?? ctx.parsed?.y ?? ctx.parsed)
        : (ctx.parsed?.y ?? ctx.raw);
      if (y == null) return lines;

      // 前回比
      const prev = ctx.dataset.data[ctx.dataIndex - 1];
      const prevY = (prev == null) ? null : (typeof prev === 'number' ? prev : (prev?.y ?? null));

      if (p.val) lines.push(`値: ${Number(y).toLocaleString('ja-JP',{maximumFractionDigits:2})}`);
      if (prevY != null) {
        const diff = y - prevY;
        const rate = (prevY===0 || prevY==null) ? '—' : (((y-prevY)/prevY)*100).toFixed(1)+'%';
        if (p.diff && p.rate) lines.push(`前回比: ${diff.toLocaleString('ja-JP',{maximumFractionDigits:2})} (${rate})`);
        else if (p.diff)      lines.push(`前回比: ${diff.toLocaleString('ja-JP',{maximumFractionDigits:2})}`);
        else if (p.rate)      lines.push(`変化率: ${rate}`);
      }

      // ▼ 全体平均（チェックON時は常に表示）
      if (p.monthly) {
        // renderChartIfReady で dataset.avgAll をセットしてある想定
        let avgAll = ctx?.dataset?.avgAll;
        if (avgAll == null) {
          // フォールバック：現在の dataset から算出
          const vals = (ctx.dataset?.data ?? [])
            .map(v => (typeof v === 'number' ? v : (v?.y ?? v)))
            .map(Number)
            .filter(Number.isFinite);
          if (vals.length) avgAll = vals.reduce((a,b)=>a+b,0) / vals.length;
        }
        if (avgAll != null) {
          lines.push(`全体平均: ${Number(avgAll).toLocaleString('ja-JP',{maximumFractionDigits:2})}`);
        }
      }

      // 追加の列（ドロップダウン）: X列は本文に出さない
      const selCols = getSelectedTooltipCols();
      if (selCols.length && Array.isArray(winRowIndexMap)) {
        const row = viewRows[ winRowIndexMap[ctx.dataIndex] ];
        const hdr = getHeadersArray();
        selCols.forEach(ci=>{
          if (ci === axisX) return; // X列は本文に出さない
          const label = hdr[ci] ?? `Col ${ci+1}`;
          const val = (row && ci < row.length) ? row[ci] : '';
          lines.push(`${label}: ${val}`);
        });
      }
      return lines;
    }

    // chart window control
    function setChartSpacer(total){
      const chartScroll = document.getElementById('chartScroll');
      const chartSpacer = document.getElementById('chartSpacer');
      if(!chartSpacer) return;
      const pxPerPoint = 12;
      const baseW = (chartScroll && (chartScroll.getBoundingClientRect().width || chartScroll.clientWidth)) || 1;
      const totalPx = Math.max(0, (total - CHART_WINDOW) * pxPerPoint);
      chartSpacer.style.width = (totalPx + baseW + 2) + 'px';
    }
    function syncStartFromScroll(total){
      const chartScroll = document.getElementById('chartScroll');
      if(total <= CHART_WINDOW){ chartViewportStart = 0; return; }
      const maxStart = total - CHART_WINDOW;
      const maxScroll = chartScroll.scrollWidth - chartScroll.clientWidth;
      const ratio = maxScroll > 0 ? (chartScroll.scrollLeft / maxScroll) : 0;
      chartViewportStart = Math.round(ratio * maxStart);
    }
    function syncScrollFromStart(total){
      const chartScroll = document.getElementById('chartScroll');
      const maxStart = Math.max(0, total - CHART_WINDOW);
      const maxScroll = chartScroll.scrollWidth - chartScroll.clientWidth;
      const ratio = maxStart > 0 ? (chartViewportStart / maxStart) : 0;
      chartScroll.scrollLeft = ratio * maxScroll;
    }
    function resetChartViewport(){
      const chartScroll = document.getElementById('chartScroll');
      chartViewportStart = 0; if(chartScroll) chartScroll.scrollLeft = 0;
    }
    (function(){
      const chartScroll = document.getElementById('chartScroll');
      if(chartScroll){
        chartScroll.addEventListener('scroll', ()=>{ renderChartIfReady(true); }, {passive:true});
        try { if ('ResizeObserver' in window) { const ro = new ResizeObserver(()=>{ if(lastChartTotal>0) setChartSpacer(lastChartTotal); }); ro.observe(chartScroll); } } catch(_) {}
      }
    })();

    function renderChartIfReady(fromScroll=false){
      const chartCanvas  = document.getElementById('chartCanvas');
      const chartPanel   = document.getElementById('chartPanel');

      if(axisX<0 || axisY<0) return;
      const {X,Y,idx} = collectXY();
      if(X.length===0){ chartPanel.style.display='none'; return; }
      chartPanel.style.display='block';

      const type = guessType(X);
      let labels=[], values=[], rowIndexMap=[];

      if(type==='scatter'){
        // Xが数値のものだけ取り込み、元行indexも保持
        for(let i=0;i<X.length;i++){
          const xn = asNumberMaybe(X[i]);
          if(xn==null) continue;
          labels.push(i);
          values.push({x:xn, y:Y[i]});
          rowIndexMap.push(idx[i]);
        }
      }else if(type==='line'){
        const agg = toDateSortedWithRep(X,Y,idx);
        labels = agg.labels; values = agg.values; rowIndexMap = agg.rowIndexMap;
      }else{
        const agg = aggregateCategoriesWithRep(X,Y,idx);
        labels = agg.labels; values = agg.values; rowIndexMap = agg.rowIndexMap;
      }

      const total = labels.length; lastChartTotal = total;
      requestAnimationFrame(()=> setChartSpacer(total));

      const maxStart = Math.max(0, total - CHART_WINDOW);
      if(fromScroll) syncStartFromScroll(total); else chartViewportStart = maxStart;

      const start = Math.max(0, Math.min(chartViewportStart, maxStart));
      const end   = Math.min(total, start + CHART_WINDOW);
      const winLabels = labels.slice(start, end);
      winRowIndexMap = rowIndexMap.slice(start, end);

      // ▼ ツールチップのタイトル（上段）にだけ Xラベルを出す
      const titleCbLineBar = (items) => (ttPrefs().xLabel ? [String(items[0]?.label ?? '')] : []);
      const titleCbScatter = (items) => {
        if(!ttPrefs().xLabel) return [];
        const x = items[0]?.raw?.x ?? items[0]?.parsed?.x ?? '';
        return [`X: ${x}`];
      };

      // ▼ 全体平均を算出（可視ウィンドウではなく全体の values から）
      let overallAvg = null;
      if (type === 'scatter') {
        const allNums = values.map(p => Number(p.y)).filter(Number.isFinite);
        overallAvg = allNums.length ? allNums.reduce((a,b)=>a+b,0) / allNums.length : null;
      } else {
        const allNums = values.map(Number).filter(Number.isFinite);
        overallAvg = allNums.length ? allNums.reduce((a,b)=>a+b,0) / allNums.length : null;
      }

      let cfgType, data, options;

if (type === 'scatter') {
  const winPoints = values.slice(start, end);
  cfgType = 'scatter';
  data = {
    datasets: [
      { label: '散布図', data: winPoints, avgAll: overallAvg }
    ]
  };
  options = {
    responsive: true,
    maintainAspectRatio: false,
    resizeDelay: 120,
    parsing: false, // {x,y}形式をそのまま使う
    scales: {
      x: {
        type: 'linear',
        title: { display: true, text: document.getElementById('axisXLabel').textContent }
      },
      y: {
        title: { display: true, text: document.getElementById('axisYLabel').textContent }
      }
    },
    plugins: {
      legend: { display: false },
      tooltip: {
        callbacks: {
          title: titleCbScatter,
          label: (ctx) => buildTooltipLines(ctx, 'scatter')
        }
      }
    }
  };

} else if (type === 'line') {
  const winValues = values.slice(start, end);
  cfgType = 'line';
  data = {
    labels: winLabels,
    datasets: [
      { label: '推移', data: winValues, tension: 0.2, avgAll: overallAvg }
    ]
  };
  options = {
    responsive: true,
    maintainAspectRatio: false,
    resizeDelay: 120,
    scales: {
      x: {
        title: { display: true, text: document.getElementById('axisXLabel').textContent }
      },
      y: {
        title: { display: true, text: document.getElementById('axisYLabel').textContent }
      }
    },
    plugins: {
      legend: { display: false },
      tooltip: {
        callbacks: {
          title: titleCbLineBar,
          label: (ctx) => buildTooltipLines(ctx, 'line')
        }
      }
    }
  };

} else {
  const winValues = values.slice(start, end);
  cfgType = 'bar';
  data = {
    labels: winLabels,
    datasets: [
      { label: '合計', data: winValues, avgAll: overallAvg }
    ]
  };
  options = {
    responsive: true,
    maintainAspectRatio: false,
    resizeDelay: 120,
    scales: {
      x: {
        title: { display: true, text: document.getElementById('axisXLabel').textContent }
      },
      y: {
        title: { display: true, text: document.getElementById('axisYLabel').textContent }
      }
    },
    plugins: {
      legend: { display: false },
      tooltip: {
        callbacks: {
          title: titleCbLineBar,
          label: (ctx) => buildTooltipLines(ctx, 'bar')
        }
      }
    }
  };
}


      if(chartInstance){ chartInstance.destroy(); chartInstance = null; }
      const ctx = chartCanvas.getContext('2d');
      chartInstance = new Chart(ctx, { type: cfgType, data, options });

      if(!fromScroll){
        syncScrollFromStart(total);
        requestAnimationFrame(()=>{ const chartScroll = document.getElementById('chartScroll'); if(chartScroll) chartScroll.scrollLeft = chartScroll.scrollWidth; });
      }
    }

    // ===== tap row to set header =====
    (function initTapToFixHeader(){
      if (!tbody) return;
      tbody.addEventListener('click', (e)=>{
        const tr = e.target.closest('tr[data-abs]');
        if (!tr) return;
        const abs = Number(tr.getAttribute('data-abs'));
        if (Number.isNaN(abs) || abs < 0) return;
        useHeader.checked = true;
        headerRowIndex = abs;
        if (headerRowInput){ headerRowInput.value = abs + 1; headerRowInput.disabled = false; }
        renderTable(currentData);
        resetChartViewport();
        renderChartIfReady();
      });
    })();


    
 

 
  // ▼ 右クリック（コンテキストメニュー）を全ページで無効化
  window.addEventListener('contextmenu', (e) => {
    e.preventDefault();
    e.stopPropagation();
  }, { capture: true, passive: false });

  // ▼ キーボードショートカットのコピー/切り取り等を全ページで無効化
  document.addEventListener('keydown', (e) => {
    const k = e.key;
    if ((e.ctrlKey || e.metaKey) && ['c','x','C','X'].includes(k)) {
      e.preventDefault();
    }
  }, { passive: false });

  // ▼ copy / cut / paste を全ページでキャンセル（クリップボード書き換えは任意）
  ['copy','cut','paste'].forEach(ev => {
    document.addEventListener(ev, (e) => {
      e.preventDefault();
      e.clipboardData?.setData('text/plain', 'このページでのコピーは無効化されています。');
    }, { passive: false });
  });

  // ▼ 画像・キャンバス・テキスト等のドラッグコピーも抑止
  document.addEventListener('dragstart', (e) => {
    e.preventDefault();
  }, { passive: false });

  // ▼ テキスト選択自体を抑止（必要なければ削除OK）
  document.addEventListener('selectstart', (e) => {
    e.preventDefault();
  }, { passive: false });



  </script>

  <footer style="text-align:center; margin:20px 0; color:#94a3b8; font-size:12px;">
  © 2025 runajuki
</footer>

</body>
</html>
